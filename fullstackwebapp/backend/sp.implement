# Phase II Backend Implementation Rules

## 1. Purpose of Implementation Phase

This phase transforms the specifications and plans created in previous phases into actual working backend code. The implementation phase takes the abstract concepts defined in sp.specify, sp.plan, and sp.tasks and creates real, functional backend components that the frontend can interact with. During this phase, we convert design decisions into executable code while maintaining the architectural integrity established in the planning phase.

## 2. Implementation Order (Very Important)

Files must be implemented in this exact sequence to ensure proper dependencies are met:

1. `db.py` → Database connection and configuration
2. `models.py` → Data models and relationships
3. `auth/JWT` → Authentication and JWT handling
4. `routes` → API route definitions and business logic
5. `main.py` → Application entry point and configuration

Following this order ensures that each layer builds properly upon the previous layer without circular dependencies.

## 3. Database Implementation Rules

- Database connection logic must be established before any models are created
- `DATABASE_URL` must always come from environment variables, never hardcoded
- No credentials should ever be stored directly in code
- Connection pooling should be configured appropriately for the application load
- Database initialization and session management follow FastAPI best practices

## 4. Model Implementation Rules

- All models must strictly follow the specifications defined in sp.specify and the Todo Domain Skill requirements
- Every Task model must have a required relationship to an authenticated User
- Foreign key relationships must enforce referential integrity at the database level
- Model validations should prevent inconsistent data from being saved
- Serialization rules must properly handle sensitive fields and relationships

## 5. Authentication & JWT Rules

- Every protected API request must be authenticated through JWT verification
- User identity must come exclusively from verified JWT tokens, never from request parameters
- When a user_id appears in the URL path, it must match the user_id contained in the JWT token
- JWT secret keys must be loaded from environment variables, never hardcoded
- Token expiration and refresh mechanisms follow industry security standards

## 6. API Route Rules

- Routes must never trust frontend input blindly - all parameters must be validated
- Ownership checks are mandatory for all operations that access user-specific data
- API responses must include appropriate HTTP status codes (401, 403, 404, etc.) for different error conditions
- Input validation must use Pydantic models to ensure type safety and consistency
- Rate limiting should be considered for public endpoints to prevent abuse

## 7. Error Handling Discipline

- No errors should ever fail silently - all exceptions must be properly logged and handled
- Error messages should be clear and informative for developers while protecting sensitive information from end users
- Custom exception classes should be created for domain-specific error conditions
- Logging should follow consistent patterns and include relevant context for debugging
- Graceful degradation should be implemented when external services are unavailable

## 8. Testing & Verification Rules

- Each file and module must be testable independently using unit tests
- Integration tests should verify the complete flow between components
- Manual testing is acceptable for the hackathon but automated tests are preferred
- Test data should be isolated and not interfere with other test runs
- Error conditions should be explicitly tested alongside happy-path scenarios

## 9. Out of Scope

- No frontend logic or UI implementation belongs in the backend codebase
- No user interface components or styling should be created in backend files
- Deployment configuration and infrastructure as code are separate concerns
- Third-party service integration beyond authentication and database should be avoided unless explicitly required

## 10. Testing & Integration Rules

### 10.1 Final Verification Process
- All existing backend placeholder files must be reviewed for completeness:
  - main.py: Check JWT authentication middleware placeholders and global application setup
  - db.py: Verify database connection and session management placeholders
  - models.py: Confirm data model definitions and relationships
  - routes/tasks.py: Validate all six endpoints with proper docstrings and guidance
  - auth.py: Ensure authentication helper functions have complete placeholders
- Verify all route placeholders have clear and comprehensive docstrings
- Ensure input validation and error handling comments are complete and consistent
- Confirm ownership and user isolation guidance is clear across all files
- Check that completion toggle endpoint guidance is consistent with other endpoints
- Verify JWT authentication and route protection placeholders are coherent

### 10.2 Integration Verification
- Identify file interaction patterns (main.py, auth.py, routes/tasks.py, db.py, models.py)
- Verify data flow from database layer through models to API endpoints
- Confirm ownership and validation rules are consistently applied
- Ensure unit and integration test placeholders are properly documented
- Validate that all files work together cohesively in the backend architecture

### 10.3 Implementation Readiness
- All placeholder comments must clearly indicate where actual implementation will occur
- Backend skeleton should be complete and ready for actual code implementation
- Security patterns (authentication, user isolation) must be properly architected
- Error handling and validation patterns should be consistent across all components
- File dependencies and import structures must be properly organized

## 11. Prompt History Recording (PHR)

- A Prompt History Record must be automatically created for this implementation phase
- The record should be saved under: `fullstackwebapp/backend/history/prompts/`
- The PHR must include the original command, implementation intent, full prompt text, and execution notes
- This historical record serves as documentation of the implementation decisions and approach taken
- Future developers can reference these records to understand why certain implementation choices were made